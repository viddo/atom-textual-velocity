/* @flow */

import statsMock from "../statsMock";
import SummaryColumn from "../../lib/columns/SummaryColumn";
import SearchMatch from "../../lib/SearchMatch";

describe("columns/SummaryColumn", function() {
  let column;

  beforeEach(function() {
    column = new SummaryColumn();
  });

  describe(".sortField", function() {
    it("should return given sort field value", function() {
      expect(column.sortField).toEqual("name");
    });
  });

  describe(".cellContent", function() {
    let note, path;

    beforeEach(function() {
      path = "/notes/markdown.md";
      note = {
        id: "",
        name: "markdown",
        ext: ".md",
        content: "# testing markdown\nshould be **Zzz** by now tho",
        stats: statsMock()
      };
    });

    describe("when there is no query applied", function() {
      let cellContent: any;

      beforeEach(function() {
        cellContent = column.cellContent({ note, path });
      });

      it("should return a kind of AST from which a DOM can be created", function() {
        expect(cellContent).toEqual(jasmine.any(Array));
        expect(cellContent[0]).toEqual("markdown", "title");
        expect(cellContent[1]).toEqual({
          attrs: { className: "text-subtle" },
          content: ".md"
        });
        expect(cellContent[2]).toEqual(
          jasmine.any(String),
          "should be a separator between title and note content preview"
        );
        expect(cellContent[3]).toEqual(
          jasmine.any(Object),
          "note content preview"
        );
        expect(cellContent[3].attrs).toEqual(jasmine.any(Object));
        expect(cellContent[3].content).toEqual(jasmine.any(String));
      });
    });

    describe("when search match in the middle of string", function() {
      it("should provide what parts of title and note content preview that should be highlighted", function() {
        const searchMatch: any = new SearchMatch(
          // as generated by sifter.js
          // eslint-disable-next-line no-misleading-character-class
          /[kƘƙꝀꝁḰḱǨǩḲḳḴḵκϰ₭][dĎďḊḋḐḑḌḍḒḓḎḏĐđD̦d̦ƉɖƊɗƋƌᵭᶁᶑȡᴅＤｄð]/i
        );
        const cellContent: any = column.cellContent({
          note,
          path,
          searchMatch
        });
        expect(cellContent).toEqual(jasmine.any(Array));
        expect(cellContent[0]).toEqual(
          jasmine.any(Array),
          "title w/ highlight"
        );
        expect(cellContent[0]).toEqual([
          "mar",
          { attrs: { className: "text-highlight" }, content: "kd" },
          "own"
        ]);
        expect(cellContent[1]).toEqual({
          attrs: { className: "text-subtle" },
          content: ".md"
        });
        expect(cellContent[2]).toEqual(" - ");
        expect(cellContent[3].content).toEqual([
          "# testing mar",
          { attrs: { className: "text-highlight" }, content: "kd" },
          "own\nshould be **Zzz** by now tho"
        ]);
      });

      it("should provide suffix part when 1st match is deep into the content", () => {
        note.content =
          Array(5000).join("x") +
          [
            "Need to some kind of comparison matrix to explain pros/cons of each solution.",
            "In addition to the random string above part of this longer text should also be included in the preview",
            "In addition to the random string above part of this longer text should also be included in the preview",
            "In addition to the random string above part of this longer text should also be included in the preview",
            "In addition to the random string above part of this longer text should also be included in the preview"
          ].join(" \n");

        const searchMatch: any = new SearchMatch(
          // eslint-disable-next-line no-misleading-character-class
          /expl/i
        );
        const cellContent: any = column.cellContent({
          note,
          path,
          searchMatch
        });
        expect(cellContent).toEqual(jasmine.any(Array));
        expect(cellContent[0]).toEqual("markdown");
        expect(cellContent[1]).toEqual({
          attrs: { className: "text-subtle" },
          content: ".md"
        });
        expect(cellContent[2]).toEqual(" - ");
        expect(cellContent[3].content).toEqual([
          "…omparison matrix to ",
          { attrs: { className: "text-highlight" }, content: "expl" },
          [
            "ain pros/cons of each solution.",
            "In addition to the random string above part of this longer text should also be included in the preview",
            "In addition to the random string above part of this longer text should also be included in the preview",
            "In addition to the random string above part of this longer text should also be included in the preview",
            "In addition to the random stri"
          ].join(" \n")
        ]);
      });
    });

    describe("when search match in the beginning of string", function() {
      it("should provide what parts of title and note content preview that should be highlighted", function() {
        const cellContent: any = column.cellContent({
          note: note,
          path: path,
          searchMatch: new SearchMatch(/m[aḀḁĂăÂâǍǎȺⱥȦȧẠạÄäÀàÁáĀāÃãÅåąĄÃąĄ]/i)
        });
        expect(cellContent[0]).toEqual([
          "",
          { attrs: { className: "text-highlight" }, content: "ma" },
          "rkdown"
        ]);
        expect(cellContent[1]).toEqual({
          attrs: { className: "text-subtle" },
          content: ".md"
        });
      });
    });

    describe("when search match at end of string", function() {
      it("should provide what parts of title and note content preview that should be highlighted", function() {
        const cellContent: any = column.cellContent({
          note: note,
          path: path,
          searchMatch: new SearchMatch(
            // eslint-disable-next-line no-misleading-character-class
            /[wẂẃẀẁŴŵẄẅẆẇẈẉ][nŃńǸǹŇňÑñṄṅŅņṆṇṊṋṈṉN̈n̈ƝɲȠƞᵰᶇɳȵɴＮｎŊŋ]/i
          )
        });
        expect(cellContent[0]).toEqual([
          "markdo",
          { attrs: { className: "text-highlight" }, content: "wn" },
          ""
        ]);
        expect(cellContent[1]).toEqual({
          attrs: { className: "text-subtle" },
          content: ".md"
        });
      });
    });

    describe("when there is no match", function() {
      it("should provide what parts of title and note content preview that should be highlighted", function() {
        const cellContent: any = column.cellContent({
          note: note,
          path: path,
          searchMatch: new SearchMatch(/Zzz/i)
        });
        expect(cellContent[0]).toEqual("markdown");
        expect(cellContent[1]).toEqual(
          { attrs: { className: "text-subtle" }, content: ".md" },
          "match of end should only contain rest+end"
        );
        expect(cellContent[3].content).toEqual([
          "…arkdown\nshould be **",
          { attrs: { className: "text-highlight" }, content: "Zzz" },
          "** by now tho"
        ]);
      });
    });
  });
});
